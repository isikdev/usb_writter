Нужно доработать скрипт для шифрования на Python: 

1) Скрипт в самом конце делит RAR архивы на части (archive PARTS). Нужно убрать эту часть с RAR и заменить её на splitter - скрипт в самом конце должен делить контейнер(НЕ архивы) на куски рандомного размера, но в заданном диапазоне. Для примера я прикрепил модуль, который как-раз предназначен для этого. Он работал с архивами; Вы можете или его модифицировать для работы с контейнером или просто по примеру сделать другой.  min_chunk_ratio 0.7 - это параметр, который означает, что диапазон должен быть не менее 70% от заданного размера. Но сейчас размеры полностью рандомные, не в диапазоне, вот это нужно исправить. Посмотрите метод _get_random_chunk_size в классе ArchivePartsRandomizer, думаю поймёте сразу.

2) Добавить опцию, запускать в режиме split или без (т.е. когда архивы делятся на рандомные части разных размеров - то, о чём была речь в предыдущем пункте... просто сейчас эта функция не опциональная и не указана в конфиге). Если в режиме split, то он должен PAR2 файлы создавать после split'a, а если в обычном, то до{сейчас создаёт только после} {т.е. это просто добавится дополнительно условие}{сейчас это частично уже реализовано, нужно в конфиг добавить параметр}. 

3) Создавать par2 файлы для контейнера, а не только для архивов, если работает в режиме контейнера{сейчас создаёт только для архивов} 

4) Небольшой рефакторинг (на Ваше усмотрение... почистить код, убрать лишнее, что-то улучшить и оптимизировать). Главное при рефакторинге не обрезать какую-нибудь фичу.

5) Разделить большие файлы на отдельные модули и поместить их в папки. Они должны быть в целом разделены по смыслу и значению, но один файл это 25-100 строк кода максимум. 100 - **абсолютный** максимум, за очень редким исключением. Иначе навигация по проекту мягко говоря неудобная. Делим по такой логике: для модулей больше 100 строк создаём отдельную папку или под-папку и туда помещаем весь код, разделив файл на несколько. 

	Примерная структура, которая должна получиться в итоге после рефакторинга и переноса кода:
	├── __main__.py
	├── obfuscate_compile.py # Pyarmor и компиляция в .EXE
	├── config/
	│   ├── __init__.py
	│   ├── schemas.py          # Валидация конфигов
	│   ├── loader.py           # Загрузка настроек
	│   ├── constants.py        # Все текстовые константы
	├── core/
	│   ├── encryption/
	│   │   ├── aes.py         # AES-шифрование
	│   │   ├── key_deriv.py   # Генерация ключей
	│   ├── archiving/
	│   │   ├── zip.py         # ZIP-архивация
	│   │   ├── rar.py         # RAR-архивация
	│   ├── container/
	│   │   ├── builder.py     # Создание контейнера
	│   │   ├── validator.py   # Проверка целостности
	│   │   ├── splitter.py    # Разделение контейнера на части
	│   ├── par2/
	│   │   ├── creator.py     # PAR2-файлы
	│   ├── disk/
	│   │   ├── par2disk/         # Под-папка с модулем для создания PAR2-файлы на целый/весь диск, например для USB-флешки.
	│   │   ├── ... все остальные файлы связанные с работой с диском ...
	├── wrappers/
	│   ├── progress.py        # Прогресс-бар
	│   ├── logger.py          # Логирование
	│   ├── safe_operations.py        # Безопасные операции. Работа с паролями и всем вытекающим
	├── tests/
	│   ├── test_encryption.py
	│   ├── test_archiving.py
	│   ├── test_container.py
	│   ├── ...
	│   ├── ETC.
	├── controllers/
	│   ├── orchestrate.py  # Основной контроллер


6) Иметь возможность запускать Pytest тесты цепочкой, а не только поочерёдно.

7) При неправильно введённом пароле - не показывать ошибку, а вываливать невалидный контейнер - так будет некоторая защита от брутфорса. 

8) Изменить прогресс бар с размеров на % (т.е. показывать не пройденный и оставшийся размер, а просто %). 

9) Файлы из _extra_compression_ при output должны быть вместе с остальными, а не в отдельной папке. Как вариант - можно в constants.py указать специальное название нужной папки.

10) Помочь разобраться с pyarmor и компиляцией скрипта в exe. В целом уже pyarmor настроен (он идёт отдельно от скрипта - смотрите файл obfuscate_compile.py), но т.к. я ни разу это не делал(т.е. ни разу не запускал этот файл), возможно понадобится помощь в процессе, но возможно и нет. Для чего это нужно: чтобы иметь под рукой утилиту, которая бы расшифровывала контейнер, но при этом, чтобы злоумышленник не мог видеть исходный код и логику работы шифрования и т.д. Это НЕ для того, чтобы получилось десктоп приложение или GUI. Опять же, как я понял, я в целом смогу сам это скомпилировать и запаковать в EXE файл с помощью Pyarmor, но т.к. я ни разу этого не делал и не знаю какие сложности возникнут, то возможно нужна будет Ваша помощь в процессе. Но скорее всего не возникнет проблем.
   

ТЕКУЩАЯ СТРУКТУРА (которую нужно скорректировать под новую структуру, что была выше): 

zip.py - создание ZIP и RAR архивов. Нужно их разделить.

logging.py - логи. 

constants.py - системные сообщения и сами тексты логов.

.JSON файлы - Конфиги 

.txt - текстовая, упрощённая версия того же конфига.

config.py - парсер конфига в текстовый.

папка utils - вспомогательные обработчики.

winDiskHandler.py - обработчик для всех операций, связанных с диском на Windows 10.

header.py - заголовки контейнера. Запись заголовков контейнера. Как я понял, используется только в режиме шифрования всег, диска, но не используется, если указываем путь до контейнера внутри диска.

penetrateFSprotection.py - на Windows существует блокировка файловой системы, которая не даёт проводить низкоуровневые операции с диском. Этот модуль позволяет разблокировать файловую систему.

папка tests - Pytest тесты.

par2deep - создание PAR2 файлов. 

controll.py - лаунчер, файл запуска всего скрипта. Т.Е. ВЕСЬ СКРИПТ ЗАПУСКАЕТСЯ ЭТИМ ФАЙЛОМ; 

КОНФИГ В encrypt-layer-1-container-brackets.txt - В НЁМ ПРОСТО УКАЖИТЕ ПУТЬ ДО ТЕСТОВЫХ ФАЙЛОВ, ЭТО ДОЛЖНА БЫТЬ ПАПКА НА ДИСКЕ НА МИНИМУМ ВТОРОМ УРОВНЕ... ЧТОБЫ ПОМЕНЯТЬ РЕЖИМ С ШИФРОВАНИЯ НА ДЕШИФРОВАНИЕ - ПОМЕНЯЙТЕ "ши" НА "де". 

core.py - ядро, как я понял основная оркестрация, но я не знаю точно. 

requirements - зависимости

Остальные файлы можете игнорировать, они к текущим доработкам не относятся (ну, разве, что к рефакторингу) 
